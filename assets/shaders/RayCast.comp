#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#include "Platform.glsl"
#include "common/Const_Func.glsl"
#include "common/Material.glsl"
#include "common/UniformBufferObject.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT Scene;
layout(binding = 1) readonly buffer RayCastInArray { RayCastContext[] RayQuery; };
layout(binding = 2) writeonly buffer RayCastOutArray { RayCastResult[] RayResult; };
//layout(binding = 3) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };
layout(binding = 4) readonly buffer VertexArray { float Vertices[]; };
layout(binding = 5) readonly buffer IndexArray { uint Indices[]; };
layout(binding = 6) readonly buffer MaterialArray { Material[] Materials; };
layout(binding = 7) readonly buffer OffsetArray { uvec2[] Offsets; };
//layout(binding = 8) uniform sampler2D[] TextureSamplers;
layout(set = 1, binding = 0) uniform sampler2D TextureSamplers[];

#include "common/RTSimple.glsl"

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

void main() {
    RayCastContext context = RayQuery[gl_GlobalInvocationID.x];

    rayQueryEXT rayQuery;
    // gl_RayFlagsTerminateOnFirstHitEXT for fast, but hit not the closet
    rayQueryInitializeEXT(rayQuery, Scene, gl_RayFlagsNoneEXT, 0xFF, context.Origin.xyz, EPS, context.Direction.xyz, INF);

    while( rayQueryProceedEXT(rayQuery) )
    {

    }

    RayCastResult hitResult;
    
    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT  ) {
        const bool IsCommitted = true;
        const int InstCustIndex = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, IsCommitted);
        const vec3 RayOrigin = context.Origin.xyz;
        const vec3 RayDirection = context.Direction.xyz;
        const float RayDist = rayQueryGetIntersectionTEXT(rayQuery, IsCommitted);
        const mat4x3 WorldToObject = rayQueryGetIntersectionWorldToObjectEXT(rayQuery, IsCommitted);
        const vec2 TwoBaryCoords = rayQueryGetIntersectionBarycentricsEXT(rayQuery, IsCommitted);
        const vec3 HitPos = RayOrigin + RayDirection * RayDist;
        const int PrimitiveIndex = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, IsCommitted);
        const int InstanceID = rayQueryGetIntersectionInstanceIdEXT(rayQuery, IsCommitted);
        
        vec3 OutNormal;
        vec2 OutTexcoord;
        int OutMaterialId;
        SimpleHit(InstCustIndex, WorldToObject, TwoBaryCoords, PrimitiveIndex, OutNormal, OutTexcoord, OutMaterialId);

        hitResult.HitPoint = vec4(HitPos, 1.0);
        hitResult.Normal = vec4(OutNormal, 0.0);
        hitResult.Hitted = 1;
        hitResult.T = RayDist;
        hitResult.InstanceId = InstanceID;
        hitResult.MaterialId = OutMaterialId;
    }
    else
    {
        hitResult.Hitted = 0;
    }
    
    RayResult[gl_GlobalInvocationID.x] = hitResult;
}