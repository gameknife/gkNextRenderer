#version 460
#extension GL_GOOGLE_include_directive : require
#include "Platform.glsl"
#include "UniformBufferObject.glsl"
#include "common/Const_Func.glsl"

layout(binding = 0, rgba16f) uniform image2D NewSourceImage;
layout(binding = 1, rgba16f) uniform image2D AccumulateImage;
layout(binding = 2, rgba16f) uniform image2D Accumulate1Image;
layout(binding = 3, rg16f) uniform image2D MotionVectorImage;
layout(binding = 4) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };

layout(binding = 5, r32ui) uniform uimage2D VisibilityBuffer;
layout(binding = 6, r32ui) uniform uimage2D Visibility1Buffer;
layout(binding = 7, rgba8) uniform image2D OutImage;
layout(binding = 8, r8ui) uniform uimage2D AdaptiveSampleBuffer;

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

// a simple accumulation shader, reproject can impl here later.
void main() {
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);

    vec4 src = imageLoad(NewSourceImage, ipos);

    bool isEvenFrame = Camera.TotalFrames % 2 == 0;

    bool useHistory = true;
    vec4 final = src;
    
    // fetch visibility to validate the history
    uint current_primitive_index = isEvenFrame ? imageLoad(VisibilityBuffer, ipos).r : imageLoad(Visibility1Buffer, ipos).r;
    if(current_primitive_index == 0 || Camera.TotalFrames == 0)
    {
         useHistory = false;
    }

    if( useHistory )
    {
		vec2 motion = imageLoad(MotionVectorImage, ipos).rg;
		ivec2 previpos = ivec2( floor(ipos + motion) );
		if( length(motion) > 0.01 )
		{
			uint prev_primitive_index0 = isEvenFrame ? imageLoad(Visibility1Buffer, previpos).r : imageLoad(VisibilityBuffer, previpos).r;
			uint prev_primitive_index1 = isEvenFrame ? imageLoad(Visibility1Buffer, previpos + ivec2(1,0)).r : imageLoad(VisibilityBuffer, previpos + ivec2(1,0)).r;
			uint prev_primitive_index2 = isEvenFrame ? imageLoad(Visibility1Buffer, previpos + ivec2(0,1)).r : imageLoad(VisibilityBuffer, previpos + ivec2(0,1)).r;
			uint prev_primitive_index3 = isEvenFrame ? imageLoad(Visibility1Buffer, previpos + ivec2(1,1)).r : imageLoad(VisibilityBuffer, previpos + ivec2(1,1)).r;

			bool miss = any( notEqual( uvec4(prev_primitive_index0, prev_primitive_index1, prev_primitive_index2, prev_primitive_index3), uvec4(current_primitive_index) ));

			if( miss)
			{
				useHistory = false;
			}
		}

		if(useHistory)
		{
			vec4 history0 = isEvenFrame ? imageLoad(AccumulateImage, previpos) : imageLoad(Accumulate1Image, previpos);
			vec4 history1 = isEvenFrame ? imageLoad(AccumulateImage, previpos + ivec2(1,0)) : imageLoad(Accumulate1Image, previpos + ivec2(1,0));
			vec4 history2 = isEvenFrame ? imageLoad(AccumulateImage, previpos + ivec2(0,1)) : imageLoad(Accumulate1Image, previpos + ivec2(0,1));
			vec4 history3 = isEvenFrame ? imageLoad(AccumulateImage, previpos + ivec2(1,1)) : imageLoad(Accumulate1Image, previpos + ivec2(1,1));

			vec2 subpixel = fract(vec2(ipos) + motion);
			vec4 history = mix(
				mix(history0, history1, subpixel.x),
				mix(history2, history3, subpixel.x),
				subpixel.y
			);

			// judge current gbuffer / object id with prev frame, to deghosting
			float currKeep = src.w / max(1, Camera.TemporalFrames);
			final = mix(history, src, currKeep);
			
			if(Camera.AdaptiveSample)
			{
				// if history variance is too large, we should not use it.
				const double historyVariance = Camera.AdaptiveVariance;

				double diff = abs(luminance(final.rgb) - luminance(history.rgb));
				if (diff > historyVariance)
				{
					// need sample
					imageStore(AdaptiveSampleBuffer, ipos, uvec4(max(1, Camera.TemporalFrames / 8)));
				}
			}
		}
    }

    if(isEvenFrame)
    {
        imageStore(Accumulate1Image, ipos, final);
    }
    else
    {
        imageStore(AccumulateImage, ipos, final);
    }

    imageStore(OutImage, ipos, vec4( final.rgb, 1.0 ));
}