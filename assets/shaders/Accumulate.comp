#version 460
#extension GL_GOOGLE_include_directive : require
#include "Platform.glsl"
#include "UniformBufferObject.glsl"
#include "common/Const_Func.glsl"

layout(binding = 0, rgba16f) uniform image2D NewSourceImage;
layout(binding = 1, rgba16f) uniform image2D AccumulateImage;
layout(binding = 2, rgba16f) uniform image2D Accumulate1Image;
layout(binding = 3, rg16f) uniform image2D MotionVectorImage;
layout(binding = 4) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };

layout(binding = 5, r32ui) uniform uimage2D VisibilityBuffer;
layout(binding = 6, r32ui) uniform uimage2D Visibility1Buffer;
layout(binding = 7, rgba8) uniform image2D OutImage;

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

// a simple accumulation shader, reproject can impl here later.
void main() {
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);

    vec2 motion = imageLoad(MotionVectorImage, ipos).rg;
    vec4 src = imageLoad(NewSourceImage, ipos);
    
    vec2 prevfpos = vec2(ipos) + motion;
    ivec2 previpos = ivec2( floor(ipos + motion) );
    vec2 subpixel = fract(prevfpos);
    bool isEvenFrame = Camera.TotalFrames % 2 == 0;

    vec4 history0 = isEvenFrame ? imageLoad(AccumulateImage, previpos) : imageLoad(Accumulate1Image, previpos);
    vec4 history1 = isEvenFrame ? imageLoad(AccumulateImage, previpos + ivec2(1,0)) : imageLoad(Accumulate1Image, previpos + ivec2(1,0));
    vec4 history2 = isEvenFrame ? imageLoad(AccumulateImage, previpos + ivec2(0,1)) : imageLoad(Accumulate1Image, previpos + ivec2(0,1));
    vec4 history3 = isEvenFrame ? imageLoad(AccumulateImage, previpos + ivec2(1,1)) : imageLoad(Accumulate1Image, previpos + ivec2(1,1));
    
    
    vec4 history = mix(
        mix(history0, history1, subpixel.x),
        mix(history2, history3, subpixel.x),
        subpixel.y
    );
    
    // find the min color of 4 history
    vec4 history_min = min(history, min(history0, min(history1, min(history2, history3))));
    // then the max
    vec4 history_max = max(history, max(history0, max(history1, max(history2, history3))));
    
    // that may bilinear to peak value, try to clamp it the color clampbox
    history = clamp(history, history_min, history_max);
    
    // clamp the history color
    //history = clamp(history, vec4(0.0), vec4(1.25));
    
    // fetch visibility to validate the history
    if( length(motion) > 0.5 )
    {
        uint current_primitive_index = imageLoad(VisibilityBuffer, ipos).r;
        uint prev_primitive_index0 = imageLoad(Visibility1Buffer, previpos).r;
        uint prev_primitive_index1 = imageLoad(Visibility1Buffer, previpos + ivec2(1,0)).r;
        uint prev_primitive_index2 = imageLoad(Visibility1Buffer, previpos + ivec2(0,1)).r;
        uint prev_primitive_index3 = imageLoad(Visibility1Buffer, previpos + ivec2(1,1)).r;

        bool miss = any( notEqual( uvec4(prev_primitive_index0, prev_primitive_index1, prev_primitive_index2, prev_primitive_index3), uvec4(current_primitive_index) ));

        if( miss )
        {
            history = src;
        }
    }

    // save to 
    uint primitive_index = imageLoad(VisibilityBuffer, ipos).r;
    if(primitive_index == 0)
    {
        history = src;
    }
    imageStore(Visibility1Buffer, ipos, ivec4(primitive_index,0,0,0));
   
    // the prev pos should bilinear sample cause it may int subpixel
    
    
    // judge current gbuffer / object id with prev frame, to deghosting
    float deghostingSpeed = 20.0f;
    uint TemporalFrames = max(1, Camera.TemporalFrames);
    float currKeep = clamp(deghostingSpeed - float(Camera.frameNum) / float(TemporalFrames), 1.0f, deghostingSpeed) / float(TemporalFrames);

    if(Camera.TotalFrames == 0)
    {
         history = src;
    }
    
    vec4 final = mix(history, src, currKeep);
    if(isEvenFrame)
    {
        imageStore(Accumulate1Image, ipos, final);
    }
    else
    {
        imageStore(AccumulateImage, ipos, final);
    }
    
    imageStore(OutImage, ipos, vec4( final.rgb, 1.0 ));
}